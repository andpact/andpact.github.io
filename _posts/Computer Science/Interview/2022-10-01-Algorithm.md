---
title: "[Interview] 알고리즘 정리"
excerpt: "면접을 대비하여 알고리즘을 정리하였습니다."

categories:
  - Interview
tags:
  - 

toc: true
toc_sticky: true
 
date: 2022-10-01
last_modified_at: 2022-10-10
---
<!-- ## ** 정렬( Sort)**
**정의**
```

```
**과정**
```

```
**의사 코드**
```

```
**소스 코드**
```java

```
**시간 복잡도 (Big-O)**
```

```
**공간 복잡도**
```

``` -->

## **선택 정렬(Selection Sort)**
**정의**
```
- 데이터 배열을 내림차순 혹은 오름차순으로 나열하는 정렬 알고리즘
- 오름차순 기준, 가장 작은 데이터를 선택하여 앞으로 보내는 정렬
- 구현이 간단하지만 입력이 커질 수록 소요시간이 크게 증가하여 비효율적인 방법
- 입력 배열 외의 추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 알고리즘 
```
**과정(오름차순)**
```
1. 주어진 리스트 속에서 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3. 맨 처음 값을 제외한 나머지 리스트를 같은 방법으로 교체한다.
4. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.
```
**의사 코드**
```
for i = 0 to n:
    a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자.
    a[i]와 a[j]의 값을 서로 맞바꾼다.
```
**소스 코드(Java)**
```java
void selectionSort(int[] list) {
    int indexMin, tmp;
    // 최소값을 찾는 과정
    for (int i = 0; i < list.length - 1; i++) {
        indexMin = i;
        for (int j = i + 1; j < list.length; j++) {
            if (list[j] < list[indexMin]) {
                indexMin = j;
            }
        }
        // 찾은 최소값을, 리스트의 맨 앞에 위치한 값과 교체
        tmp = list[indexMin];
        list[indexMin] = list[i];
        list[i] = tmp;
    }
}
```
**시간 복잡도 (Big-O)**
```
- 리스트 크기와 상관없이, 상수 시간이 소요되는 작업은 제외
- 바깥쪽 for 반복문은 n - 1번의 작업을 수행
- 안쪽 for 반복문은 (n - 1) + (n - 2) + ... + 2 + 1 = n(n + 1)번의 작업 수행
- n의 가장 높은 차수만 고려했을 때, 시간 복잡도는 O(n^2)
```
**공간 복잡도**
```
- 주어진 배열 안에서, 값의 교환을 통해 정렬이 수행되므로 공간 복잡도는 O(n)
```
## **삽입 정렬(Insertion Sort)**
**정의**
```

```
**과정**
```

```
**의사 코드**
```

```
**소스 코드**
```java

```
**시간 복잡도 (Big-O)**
```

```
**공간 복잡도**
```

```