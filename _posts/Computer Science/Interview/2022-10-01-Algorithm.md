---
title: "[Interview] 알고리즘 정리"
excerpt: "면접을 대비하여 알고리즘을 정리하였습니다."

categories:
  - Interview
tags:
  - 

toc: true
toc_sticky: true
 
date: 2022-10-01
last_modified_at: 2022-10-10
---
<!-- ## ** 정렬( Sort)**
**특징**
```

```
**과정**
```

```
**의사 코드**
```

```
**소스 코드**
```java

```
**시간 복잡도 (Big-O)**
```

```
**공간 복잡도**
```

``` -->

## **선택 정렬(Selection Sort)**
**특징**
```
- 데이터 배열을 내림차순 혹은 오름차순으로 나열하는 정렬 알고리즘
- 오름차순 기준, 가장 작은 데이터를 선택하여 앞으로 보내는 정렬
- 구현이 간단하지만 입력이 커질 수록 소요시간이 크게 증가하여 비효율적인 방법
- 입력 배열 외의 추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 알고리즘 
```
**과정(오름차순)**
```
1. 주어진 리스트 속에서 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
3. 맨 처음 값을 제외한 나머지 리스트를 같은 방법으로 교체한다.
4. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.
```
**의사 코드**
```
for i = 0 to n:
    a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자.
    a[i]와 a[j]의 값을 서로 맞바꾼다.
```
**소스 코드(Java)**
```java
void selectionSort(int[] list) {
    int indexMin, tmp;
    // 최소값을 찾는 과정
    for (int i = 0; i < list.length - 1; i++) {
        indexMin = i;
        for (int j = i + 1; j < list.length; j++) {
            if (list[j] < list[indexMin]) {
                indexMin = j;
            }
        }
        // 찾은 최소값을, 리스트의 맨 앞에 위치한 값과 교체
        tmp = list[indexMin];
        list[indexMin] = list[i];
        list[i] = tmp;
    }
}
```
**시간 복잡도 (Big-O)**
```
- 리스트 크기와 상관없이, 상수 시간이 소요되는 작업은 제외
- 바깥쪽 for 반복문은 n - 1번의 작업을 수행
- 안쪽 for 반복문은 (n - 1) + (n - 2) + ... + 2 + 1 = n(n + 1)번의 작업 수행
- n의 가장 높은 차수만 고려했을 때, 시간 복잡도는 O(n^2)
```
**공간 복잡도**
```
- 주어진 배열 안에서, 값의 교환을 통해 정렬이 수행되므로 공간 복잡도는 O(n)
```
---
## **삽입 정렬(Insertion Sort)**
**특징**
```
- 데이터 배열을 내림차순 혹은 오름차순으로 나열하는 정렬 알고리즘
- 입력 배열 외의 추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 알고리즘
- 두 번째 자료부터 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
- 무조건 위치를 교환하는 선택 정렬과 버블 정렬에 비해 다소 효율적
```
**과정**
```
1. 2번째 위치(index)의 값을 tmp에 저장한다.
2. tmp의 값과 이전에 있는 원소들과 비교하며 적절한 위치에 삽입한다.
3. '1'번 과정으로 돌아가 다음 위치(index)의 값을 tmp에 할당하고, 반복한다.
4. 마지막 위치(index)의 값을 적절한 위치에 삽입하고 과정을 종료한다.
```
**의사 코드**
```

```
**소스 코드**
```java
void insertionSort(int[] arr) {
   for(int index = 1 ; index < arr.length ; index++){
      int tmp = arr[index];
      int aux = index - 1;
      while( (aux >= 0) && ( arr[aux] > tmp ) ) {
         arr[aux + 1] = arr[aux];
         aux--;
      }
      arr[aux + 1] = tmp;
   }
}
```
**시간 복잡도 (Big-O)**
```

```
**공간 복잡도**
```

```