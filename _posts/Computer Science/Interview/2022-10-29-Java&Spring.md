---
title: "[Interview] Java & Spring"
excerpt: "Java & Spring 정리"

categories:
  - Interview
tags:
  - 

toc: 
toc_sticky:
 
date: 2022-10-29
last_modified_at: 2022-11-26
---

개인적인 의견이 포함되어 있고, 잘못된 정보가 있을 수 있습니다.

---

## **객체 지향 언어**
- 객체를 구성하여 프로그래밍을 할 수 있게 하는 언어
- 클래스를 사용하여 객체를 생성함.
- 같은 객체를 생성하더라도 하나의 클래스로 부터 생성이 되므로 유지보수가 편한 장점이 있음.

## **클래스**
- 객체의 속성과 기능을 변수와 함수로 정의해 놓은 것
- 클래스로 부터 인스턴스를 생성할 수 있음.
- 객체 지향 프로그래밍을 위해 클래스를 작성함.

## **객체(Object)**
- 우리 주변에 존재하는 속성과 기능을 가진 유형 또는 무형의 어떤 것
- 객체의 속성과 기능을 클래스로 정의하여 프로그래밍에 사용할 수 있음.
- 프로그래밍에서 우리가 원하는 것을 만들기 위해 객체를 사용함.

## **인스턴스(Instance)**
- 어떤 클래스로부터 실제로 만들어진 객체
- 클래스를 통해 객체를 생성하면 인스턴스가 됨.
- 프로그래밍에서 객체를 사용하기 위해서 인스턴스를 생성함.

## **사용자 정의 타입(User-defined-type)**
- 기본 자료형 외에 사용자가 정의하는 타입
- 사용자가 서로 관련된 변수를 묶어서 정의하는 것이고 이것이 곧 클래스가 됨.
- 기본 자료형으로 나타낼 수 없는 타입을 나타내기 위해 사용함.

## **변수**
- 클래스 변수
  - 인스턴스 생성과는 별개로 항상 같은 값을 유지하는 변수, 선택적 초기화
  - 클래스 영역 내의 변수에 static를 붙여 선언하고 클래스가 메모리에 올라 갈 때 생성됨.
  - 인스턴스가 모두 같은 값을 유지해야 하는 속성일 경우 클래스 변수로 선언함.
- 인스턴스 변수
  - 생성된 인스턴스마다 다른 값을 가질 수 있는 변수, 선택적 초기화
  - 클래스 영역 내에 변수를 선언하고, 인스턴스가 생성되었을 때 생성됨.
  - 인스턴스마다 고유한 값을 가져야하는 속성의 경우 인스턴스 변수로 선언함.
- 지역 변수
  - 클래스 영역 외인 메서드 내에서만 사용되는 변수, 필수적 초기화
  - 메서드 내에 변수를 선언하고, 변수 선언문이 실행되었을 때 생성됨.
  - 메서드 내에서만 사용될 속성의 경우 지역 변수로 선언함.

## **메서드**
- 특정 작업을 수행하는 기능들을 하나로 묶어놓은 것
- 선언부와 구현부로 나누어서 작성함.
- 반복 호출이 가능하고, 중복 코드를 제거할 수 있어 프로그래밍의 유지 보수를 위해 사용함.
- 클래스 메서드(Class method)
  - 인스턴스 변수를 사용하지 않는 메서드
  - 인스턴스를 생성할 필요가 없는 메서드일 때 클래스 메서드를 사용함.
  - 메서드 앞에 static 키워드를 붙여 클래스 메서드로 사용함.
- 인스턴스 메서드(Instance method)
  - 인스턴스 변수를 사용하는 메서드
  - 각 인스턴스 마다 수행해야 할 동작이 있을 때 인스턴스 메서드를 사용한다.
  - 클래스의 멤버변수로 메서드를 선언하면 인스턴스 메서드가 된다.

## **인자(Argument)와 매개변수(Parameter)**
- 인자(인수)는 메서드 호출 시 지정하는 변수, 매개변수는 메서드 수행 시 사용되는 변수
- 메서드 호출 시 지정한 인자가 메서드가 수행 될 때 매개변수에 대입(복사)되기 때문에 둘의 타입이 일치하거나 자동 형변환이 가능한 것이어야 함.

<!-- ## **JVM의 메모리 구조**
-  -->

## **재귀 호출(Recursive call)**
- 메서드 내부에서 메서드 자신을 다시 호출하는 것
- 재귀 호출 시 지속적으로 인자가 매개변수로 대입(복사)되어 진행됨. 무한 호출을 막기 위한 조건문이 필요
- 반복을 수행하기 위한 하나의 종류이고, 매개변수 복사, 호출 종류 후 복귀할 주소 저장 등으로 인해 일반 반복문보다 시간이 오래걸림. 하지만 간결하게 사용할 수 있음.

## **오버로딩(Overloading)**
- 한 클래스 내에 같은 이름의 메서드를 여러 개 선언하는 것
- 매개 변수만 다르고 같은 기능을 하는 메서드의 이름을 통일하여 부담을 줄이기 위해 사용한다.
- 메서드의 이름은 같되, 매개 변수의 개수나 타입을 다르게 작성하면 오버로딩이 된다.

## **멤버 변수 초기화**
- 생성자(Constructor)
  - 인스턴스가 생성될 때 호출되는 메서드
  - 인스턴스가 생성될 때 수행되어야 하는 작업(인스턴스 변수 초기화 등)을 위해 사용한다.
  - 클래스의 이름과 동일한 메서드를 클래스 내에 선언하여 사용한다.
- 명시적 초기화(Explicit initialization)
  - 멤버 변수를 선언과 동시에 초기화 하는 것
  - 변수 선언과 초기화만 필요한 간단한 초기화를 할 때 사용한다.
  - 멤버 변수를 선언하고 값을 할당해 주면 명시적 초기화가 된다.
- 초기화 블럭(Initialization block)
  - 초기화 블럭 내에서 멤버 변수를 초기화 하는 것
  - 메서드사용이 필요한 초기화 처럼 초기화 작업이 복잡하여 명시적 초기화로 부족할 경우에 사용한다.
  - 클래스 내에 중괄호를 이용한 블럭을 생성하여 초기화 작업을 진행한다.
- 초기화 시점
  - 클래스 변수 : 클래스가 메모리에 로딩될 때 한번만 초기화
  - 인스턴스 변수 : 인스턴스가 생성될 때마다 인스턴스마다 초기화
- 초기화 순서
  - 클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
  - 인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

---

## **상속(Inheritance)**
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
- 기존 클래스의 멤버를 상속 받아 적은 양의 코드로 새로운 클래스를 작성할 수 있기 때문에 효율적이다.
- 새로운 클래스의 이름에 extends 키워드와 상속받고자 하는 클래스의 이름을 작성하여 상속을 한다.

## **클래스간 관계**
- 상속 관계
  - 기존 클래스의 멤버 변수를 그대로 새로운 클래스로 가져오는 관계
- 포함 관계
  - 기존 클래스의 인스턴스를 새로운 클래스에 생성하여 사용하는 관계

## **오버라이딩(Overriding)**
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
- 기능은 같지만 새로운 클래스에 추가된 멤버를 사용하는 메서드를 정의하기 위해 사용한다.
- 메서드의 선언부는 그대로 두고 구현부만 변경하면 오버라이딩이 된다.

## **패키지(Package)**
- 클래스의 묶음
- 서로 관련된 클래스를 묶어 효율적으로 관리할 수 있다.
- 패키지는 하나의 파일일 뿐이므로, 파일을 하나 만들고 그 안에 클래스 파일들을 넣으면 패키지가 된다.

## **제어자(Modifier)**
- 클래스, 멤버 변수 또는 메서드의 선언부에 함께 사용하여 부가적인 의미를 주는 것
- 접근 제어자(Access modifier)
  - 멤버 또는 클래스를 외부에서 접근하지 못하도록 막는 역할
  - 접근을 막아 클래스 내부에 선언되 데이터를 보호하기 위해 사용한다.
  - 접근 범위 넒음 public > protected > (default) > private 좁음
- 그 외 제어자
  - static, final, abstract

## **다형성(Polymorpism)**
- 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 한 것
- 자손 클래스를 생성하긴 하지만, 조상 클래스로부터 상속받은 멤버만 사용할 경우 다형성을 이용한다.
- 조상 클래스 타입의 참조 변수를 선언하고, 자손 클래스의 인스턴스를 할당하여 다형성을 이용한다.

## **추상 클래스(Abstarct class)**
- 미완성(추상) 메서드를 포함하고 있는 클래스
- 추상 메서드를 포함하고 있기 때문에 인스턴스를 생성할 수 없기에 단독으로 사용되지 않고, 자손 클래스에서 추상 메서드를 오버라이딩해서 사용하는 경우를 위해서 추상 클래스를 사용한다.
- 클래스 앞에 abstract 키워드를 붙이고, 내부에는 메서드의 선언부만 작성하고, 구현부는 비워둔 메서드인 추상 메서드를 작성하면 추상 클래스가 된다.

## **인터페이스(Interface)**
- 오직 추상 메서드와 상수만을 멤버로 갖는 일종의 추상 클래스

<!-- ## **내부 클래스(Inner class)** -->

## **익명 클래스(Anonymous class)**
- 상속 방법 중 하나로, 클래스의 선언과 인스턴스 생성을 동시에 하는 클래스
- 한번만 사용되고 하나의 객체만 생성해야 하는 상황에 사용되는 일회용 클래스
- 상속 할 조상 클래스나 인터페이스를 키워드 new를 통해 생성함과 동시에 중괄호를 이용해서 멤버를 작성해준다.

---

## **지네릭스(Generics)**
- 클래스나 메서드 내에서 다룰 객체의 타입을 미리 명시하는 것
- 객체의 타입을 미리 명시 하기 때문에 의도한 타입의 객체만 사용되도록 할 수 있는 장점이 있다.
- 클래스나 메서드의 선언부 꺽어진 괄호(<>)를 사용하여 에 타입을 미리 명시하여 사용한다.

<!-- ## **와일드 카드(Wild card)**
- 제네릭스에서 변수 타입의 상한과 하한을 정하는 것 -->

## **열거형(Enums)**
- 관련 있는 여러 상수를 한 번에 묶어서 선언하기 위한 것
- 열거형을 사용하면 코드가 짧아지고, 상수를 열거형 타입으로 감싸 유용하게 사용할 수 있다.
- enum 키워드와 중괄호를 사용하여 열겨형을 사용할 수 있다.

## **애너테이션(Annotation)**
- 컴파일러와 같은 프로그램에게 코드의 정보를 제공하는 것
- 코드의 정보를 미리 제공해 의도치 않은 실수를 방지할 수 있다.
- 애너테이션을 사용하고자 하는 대상 앞에 골뱅이 문자(@)와 애너테이션 이름을 적어서 사용한다.

## **프로세스(Process)**
- 메모리에 적재된 현재 실행 중인 프로그램
- 실행 중인 프로그램을 구분하고 자원을 할당하기 위해서 프로세스라는 개념을 사용한다.
- 프로그램을 실행하면 운영체제로 부터 실행에 필요한 자원을 할당받아 프로세스가 된다.

## **쓰레드(Thread)**
- 프로세스 내의 작업 흐름
- 하나의 프로세스 안에서 여러 부분을 실행하기 위해 쓰레드를 사용한다.
- Thread 클래스를 상속하거나, Runnable 인터페이스를 구현해서 사용한다.

## **데몬 쓰레드(Daemon Thread)**
- 일반 쓰레드를 돕는 보조 쓰레드
- 가비지 컬렉터, 자동 저장, 화면 자동 갱신

## **람다식(Lambda expression)**
- 메서드를 값을 나타내는 식으로 표현한 것, 메서드를 변수처럼 다루는 것
- 클래스나 객체 생성 없이 사용 가능하고, 변수처럼도 사용 가능하므로 편리하다.
- 메서드의 이름과 반환문을 없애고, 매개 변수 선언부와 메서드 구현부만 남겨 익명 함수처럼 사용한다.

## **함수형 인터페이스(Functional interface)**
- 람다식이 실제로 선언되어 있는 익명 인터페이스
- 람다식을 사용하면 자동으로 객체가 생성되도록 하여 클래스나 객체 생성 없이 람다식을 사용할 수 있도록 한다.
- 익명 클래스를 생성함과 동시에 람다식으로 사용할 메서드를 선언하면 함수형 인터페이스가 되고 람다식으로 사용할 수 있다.

## **스트림(Stream)**
- 자료 구조의 형태에 관계없이 데이터를 동일하게 다룰 수 있게 자료 구조를 추상화한 것
- 같은 기능의 메서드가 다른 자료 구조에 중복 정의되어 있지만 상이한 방식으로 다룰 때의 문제를 해결하기 위해 스트림을 사용한다.
- 다른 형태의 자료 구조를 스트림 형태로 변환하면 같은 기능을 동일한 방식으로 실행할 수 있다.

---

## **브라우저(Browser)**
- 화면을 통해 서버에 요청을 보내고, 응답을 받아 화면에 표시하는 클라리언트 프로그램
- 사용자와 서버간의 상호작용(요청과 응답)을 쉽고 편리하게 하기 위해서 사용한다.
- URL로 요청을 보내고 요청에 대한 응답이 화면으로 표시된다.

## **WAS(Web application server)**
- 고정된 데이터를 전달하는 웹 서버와 달리 매번 새로운 데이터를 전달할 수 있는 서버
- 새로운 데이터를 만들어 내서 사용자와 상호작용하기 위해서 사용한다.
- 브라우저를 통해서 프로그램과 상호작용을 하고, 이로 인해 생성된 데이터를 화면으로 표시한다.

## **요청(Request)**
- 브라우저를 통해서 사용자가 서버에 데이터를 요구하는 것
- 사용자가 데이터를 조회하거나 특정 작업을 수행하기 위해 사용한다.
- 조회를 위해 GET방식을 사용하고, 작업을 수해하기 위해 POST방식을 사용한다.

## **응답(Response)**
- 사용자의 요청에 따라 서버가 데이터를 전달하는 것
- 원하는 데이터를 사용자에게 전달하기 위해 사용한다.
- 요청에 따라 정적데이터 혹은 동적데이터를 전달한다.

## **HTTP(Hyper text transfer protocol)**
- 클라이언트의 요청과 서버의 응답 사이의 데이터 교환 약속
- 데이터 교환 방식을 통일하기 위해서 사용한다.
- 요청과 응답을 묶어서 HEADER과 BODY라는 틀을 사용해서 처리한다.

## **서블릿(Servlet)**
- 서버에서 동적으로 요청과 응답을 처리할 수 있는 API를 정의한 것
- 자바 프로그래밍에서 사용자와 상호작용 하기 위해서 서블릿을 사용한다.
- 서블릿 컨테이너(서버)를 통해 서블릿 인스턴스를 서블릿 저장소인 서블릿 컨텍스트에 생성하여 사용자의 요청을 받고 서버의 응답을 줄 수 있다.

## **JSP(Java server pages)**
- 서블릿과 동일하게 동적으로 데이터를 구성하는 기술
- HTML 코드를 그대로 사용하기 때문에 화면을 구성하는 용도로 사용한다.
- JSP파일이 결국 서블릿 코드로 변환되어서 컴파일 되며, 서블릿과 같은 방식으로 사용된다.

## **쿼리 스트링(Query string)**
- 서버에게 어떤 값을 전달하기 위해서 브라우저의 주소창에 사용하는 것
- 사용자가 서버에 데이터와 함게 요청을 해야 할 경우에 쿼리 스트링을 사용한다.
- URL뒤에 물음표와 파라미터를 전달하여 사용한다.

## **MVC구조(Model-View-Controller)**
- 프로그램을 데이터 처리, 데이터 출력, 데이터 가공으로 계층화한 구조
- JSP가 출력에 적합하고, 서블릿이 가공에 적합하기 때문에 책임과 역학을 구분하기 위해 MVC구조를 사용한다.
- 사용자의 요청을 서블릿이 받아서 데이터를 가공하고, JSP에 데이터를 넘겨서 출력한다.

## **PRG패턴(Post-Redirect-Get)**
- POST방식 처리 후 GET방식으로 화면을 출력하는 패턴
- POST방식 이후에 결과를 확인하기 위해서 GET을 호출하는 PRG패턴을 사용한다.
- 서블릿에서 POST방식을 처리하고, 브라우저에게 호출해야하는 주소를 전달한 뒤, 브라우저는 받은 주소를 GET방식으로 호출한다.

## **모델(Model)**
- MVC구조에서 View와 Controller의 기능을 뺀 나머지 부분
- 요청과 응답 사이의 데이터 처리을 위해 모델 개념을 사용한다.
- DTO와 서비스 객체를 구성하여 모델의 역할을 수행한다.

## **DTO(Data transfet object)**
- MVC구조에서 계층간 전달되는 데이터를 나타내는 객체
- View와 Controller에 데이터를 전달하기 위해 DTO를 사용한다.
- 전달하고자 하는 데이터를 DTO로 묶어서 서비스 객체를 통해 각 계층을 이동하면서 사용한다.

## **서비스 객체**
- MVC구조에서 데이터 처리에 사용되는 객체
- DTO를 컨트롤러로 보내기 위한 데이터 가공에 서비스 객체가 사용된다.
- 컨트롤러에서 서비스 객체를 호출하여 데이터를 전달받고 JSP로 데이터를 넘겨준다.

## **DDL(Data definition language)**
- DB에 테이블을 생성하는 SQL
- 테이블을 생성하지 않으면 데이터를 저장할 수 없기 때문에 DDL을 이용하여 테이블을 생성한다.
- DDL에 해당하는 SQL을 사용하여 열과 행으로 이루어진 테이블을 생성하고 데이터를 저장한다.

## **DML(Data manipulation language)**
- DB의 데이터를 조작하는 SQL
- 테이블에 변경사항이 있을 때 DML을 사용하여 데이터를 조작한다.
- Insert, Update, Delete등의 키워드와 함께 사용한다.

## **쿼리(Query)**
- DB의 데이터를 조회할 때 사용하는 SQL
- 테이블에서 조회할 데이터가 있을 경우 쿼리를 사용한다.
- select 키워드와 함께 사용한다.

## **DAO(Data access object)**
- DB의 접근을 위해 SQL을 실행하는 객체, JDBC프로그램
- DB의 데이터를 조작하기 위해서 DAO를 사용한다.
- 클래스 내부에 SQL을 작성해서 사용한다.

## **VO(Value object)**
- DB의 한 행을 자바의 객체로 표현한 것
- DB의 데이터를 자바 프로그램 내에서 사용하기 위해서 VO로 만들어서 사용한다.
- 데이터를 클래스로 정의하여 프로그램 내에서 사용할 수 있도록 한다.

## **쿠키(Cookie)**
- 브라우저와 서버가 주고 받는 문자열로 만들어진 데이터이며 키와 값으로 이루어져 있다.
- 요청과 응답이 이루어지면 이에 대한 정보가 남지 않기 때문에, 정보를 남기기 위해서 쿠키를 사용한다.
- 쿠키를 브라우저에 저장하거나, 파일 형태로 컴퓨터 상에 저장하여 필요할 때 사용한다.

## **세션 저장소(Session Repository)**
- 서버에서 발행하는 쿠키(개발자가 만든 쿠키가 아닌)를 브라우저 상에 저장하기 위한 공간이며 키와 값으로 이루어져 있다.
- 요청과 응답과 관계 없이 브라우저가 실행되는 동안 필요한 정보를 저장하기 위해 세션 저장소를 사용한다.
- 서버에서 세션 저장소(Key)를 생성하고, 서블릿이나 JSP에서 객체를 세션 컨텍스트(Value)에 저장하여 사용한다.

## **필터(Filter)**
- 요청이 컨트롤러에 도착하기 전에 필터링 하는 역할
- 컨트롤러 마다 필터 역할을 하는 기능을 작성할 수 없으니, 한 번에 묶어서 필터에 작성한다.
- 필터에 해당하는 클래스를 작성하고, 경로를 설정해 사용한다.

## **EL 스코프(Scope)**
- JSP 내부에서 외부의 데이터를 참조하는 EL이 데이터를 참조하는 범위
  - Parameter scope : URL의 쿼리 스트링으로 넘어온 값
  - Page scope : JSP에서 EL을 통해 <c:set>으로 저장한 변수
  - Request scope : HttpServletRequest에 setAttribute()로 저장한 변수
  - Session scope : HttpSession을 이용해서 setAttribt()로 저정한 변수
  - Application scope : ServletContext를 이용해서 setAttribute()로 저장한 변수

## **스프링(Spring)**
- 의존성 주입 개념을 적용할 수 있는 프레임워크
<!-- - 
-  -->

## **의존성 주입(Dependency injection)**
- 스프링이 객체 지향 구조를 설계할 때 사용하는 개념으로 의존성(필요도)이 높은 객체의 관리(생성, 활용)를 스프링이 대신 해주는 것이고 필드 주입과 생성자 주입방식이 있다.
<!-- -  -->
- 스프링 설정 파일(root-context.xml)이나, 별도의 클래스를 작성하여 의존성 주입을 할 수 있다.

## **빈(Bean)**
- 스프링이 의존성 주입을 위해 관리하는 의존성이 높은 객체
<!-- -  -->
- 스프링 설정 파일을 읽어서 어플리케이션 컨텍스트가 생성되고 빈이 저장된다.


## **어플리케이션 컨텍스트(Application context)**
- 스프링의 빈이 저장되어 관리되는 공간
<!-- -  -->
- 스프링 설정 파일을 읽어서 어플리케이션 컨텍스트가 생성되고 빈이 저장된다.

## **스프링 MVC**
- 기존 MVC 구조에 다양한 기능을 접목시킨 것
  - Front-Controller 패턴
  - 애너테이션 활용(@Controller, @Request mapping, @Get mapping, @Post mapping..)
  - 컨트롤러 내 메서드의 파라미터 자동 수집과 변환
- 이전보다 코드가 짧아져 개발 시간을 단축시킬 수 있다.
<!-- -  -->

