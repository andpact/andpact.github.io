---
title: "[LeetCode] 1. Two Sum"
excerpt: "LeetCode 1번 문제와 솔루션"

categories:
  - LeetCode
tags:
  - 

toc: true
toc_sticky: true
 
date: 2022-08-26
last_modified_at: 2023-01-04
---
## **Problem**
Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have **exactly one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

**Example 1:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```
**Example 2:**
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
**Example 3:**
```
Input: nums = [3,3], target = 6
Output: [0,1]
```
**Constraints:**
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **Only one valid answer exists.**

**Follow-up**: Can you come up with an algorithm that is less than `O(n^2)` time complexity?

---
## **Solution**
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++)
            for (int j = i + 1; j < nums.length; j++)
                if (nums[i] + nums[j] == target)
                    return new int[]{i, j};
        return new int[]{0, 0};
    }
}
```
## **Explanation**
- 배열 속 두 요소의 값을 더해서 target이 되는지 확인하기 위해서 배열 속 모든 요소를 더해 target과 비교하는 과정이 필요하다.
- for반복문을 중첩 작성하여 배열 속 두 요소를 가리킬 준비를 한다. 이 때 `내부에 중첩된 for반복문의 변수 j는 바깥 for반복문의 변수 i보다 1큰 값으로 시작`하게 하여, 같은 요소가 계산에 사용되는 것과 중복 계산을 방지하도록 한다.
```java
for (int i = 0; i < nums.length; i++)
    for (int j = i + 1; j < nums.length; j++)
```
- 문제에서는 더해서 target이 되는 요소의 쌍이 오직 하나만 존재한다는 조건을 제시하고 있으므로, 배열의 두 요소의 합이 target이 되면 즉시 새로운 배열을 생성하고, 두 요소의 지수를 요소로하는 배열을 반환하도록 한다.
```java
if (nums[i] + nums[j] == target)
    return new int[]{i, j};
```
- 제출을 위해 임시로 반환문을 작성한다.
```java
return new int[]{0, 0};
```