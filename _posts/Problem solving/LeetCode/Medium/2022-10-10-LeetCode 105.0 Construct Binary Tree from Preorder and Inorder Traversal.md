---
title: "[LeetCode] 105. Construct Binary Tree from Preorder and Inorder Traversal"
excerpt: "LeetCode 105번 문제와 솔루션"

categories:
  - LeetCode
tags:
  - 

toc: true
toc_sticky: true
 
date: 2022-10-10
last_modified_at: 2022-11-08
---
## **Problem**
Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return *the binary tree*.

**Example 1:**

![image](https://user-images.githubusercontent.com/107045604/194890046-8a1433dd-8915-4376-b690-3afd12d7689e.png)

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```
**Example 2:**
```
Input: preorder = [-1], inorder = [-1]
Output: [-1]
```
**Constraints:**
- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` and `inorder` consist of **unique** values.
- Each value of `inorder` also appears in `preorder`.
- `preorder` is **guaranteed** to be the preorder traversal of the tree.
- `inorder` is **guaranteed** to be the inorder traversal of the tree.

---
## **Solution**
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(0, 0, inorder.length - 1, preorder, inorder);
    }
    // 무슨 반복을 하는 재귀 함수인지?
    public TreeNode helper(int preRoot, int inLeft, int inRight, int[] preorder, int[] inorder) {
        // 재귀 함수 호출 중단(null 반환)
        if (preRoot > preorder.length - 1 || inLeft > inRight) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preRoot]);
        int inRoot = 0;
        for (int i = inLeft; i <= inRight; i++)
            if (inorder[i] == root.val)
                inRoot = i;
        root.left = helper(preRoot + 1, inLeft, inRoot - 1, preorder, inorder);
        root.right = helper(preRoot + inRoot - inLeft + 1, inRoot + 1, inRight, preorder, inorder);
        return root;
    }
}
```
배열 pre, in을 돌아다닐 인덱스가 필요함.
root노드를 가르키기 위한 인덱스
head노드를 아는 체 메서드를 시작할 수 있다.
배열 pre의 첫 요소가 head가 된다. 그리고 각 배열의 요소들은 unique하므로, 배열 in에서 head노드를 찾을 수 있고, head의 왼쪽 요소들은 head의 좌측 트리, 오른쪽 요소들은 우측 트리가 된다. 그리고 왼쪽, 오른쪽 트리를 나눌 수 있으면, 다시 head노드를 찾을 수 있고, 다시 왼쪽 오른쪽 나눌 수 있다.
## **Explanation**
- 이진 트리를 만들려면 root노드를 만들고 아래로 내려가면서 자식노드를 생성하는 반복이 필요하다. 본 문제에서는 재귀 함수를 작성하여 반복 작업을 처리하도록 한다.