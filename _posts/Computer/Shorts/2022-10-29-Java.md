---
title: "[Shorts] Java"
excerpt: "Java Shorts"

categories:
  - Shorts
tags:
  - 

toc: 
toc_sticky:
 
date: 2022-10-29
last_modified_at: 2023-02-01
---
<!-- Chapter 6 -->
## **객체 지향 언어**
- 현실 세계의 사물이나 개념을 객체로 표현해 프로그램을 만들기 위한 언어

## **클래스(Class)**
- 객체의 속성과 기능을 변수와 함수로 정의해 놓은 것

## **객체(Object)**
- 실제로 존재하는 사물 또는 개념

## **인스턴스(Instance)**
- 어떤 클래스로부터 실제로 만들어진 객체

## **사용자 정의 타입(User-defined-type)**
- 기본 자료형 외에 사용자가 정의하는 타입(클래스)

## **변수(Variable)**
- 객체의 속성을 나타내기 위한 것
- 클래스 변수(Class Variable)
  - 인스턴스 생성없이 사용 가능하고, 모든 인스턴스가 같은 값을 유지하는 변수, 선택적 초기화
- 인스턴스 변수(Instance Variable)
  - 인스턴스를 생성해야 사용 가능하고, 생성된 인스턴스마다 다른 값을 가질 수 있는 변수, 선택적 초기화
- 지역 변수(Local Variable)
  - 클래스 영역 외인 메서드 내에서만 사용되는 변수, 필수적 초기화

## **메서드(Method)**
- 객체의 기능을 나타내기 위한 것
- 클래스 메서드(Class method)
  - 인스턴스를 생성하지 않고, 인스턴스 변수를 사용하지 않는 메서드
- 인스턴스 메서드(Instance method)
  - 인스턴스를 생성하고, 인스턴스 변수를 사용하는 메서드

## **인자(Argument)와 매개변수(Parameter)**
- 인자(인수) : 메서드 호출 시 사용하는 변수
- 매개변수 : 메서드 작성 시 작성하는 변수

<!-- ## **JVM의 메모리 구조**
-  -->

<!-- ## **재귀 호출(Recursive call)**
- 메서드 내부에서 메서드 자신을 다시 호출하는 것
- 재귀 호출 시 지속적으로 인자가 매개변수로 대입(복사)되어 진행됨. 무한 호출을 막기 위한 조건문이 필요
- 반복을 수행하기 위한 하나의 종류이고, 매개변수 복사, 호출 종류 후 복귀할 주소 저장 등으로 인해 일반 반복문보다 시간이 오래걸림. 하지만 간결하게 사용할 수 있음. -->

## **오버로딩(Overloading)**
- 한 클래스 내에 같은 이름의 메서드를 매개변수만 다르게하여 여러 개 선언하는 것

## **변수 초기화**
- 생성자(Constructor)
  - 인스턴스가 생성될 때 호출되어 변수를 초기화하는 메서드
- 명시적 초기화(Explicit initialization)
  - 변수를 선언과 동시에 초기화 하는 것
- 초기화 블럭(Initialization block)
  - 클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용
  - 인스턴스 초기화 블럭 : 인스턴스 변수의 복잡한 초기화에 사용
- 초기화 시점
  - 클래스 변수 : 클래스가 메모리에 로딩될 때 한번만 초기화
  - 인스턴스 변수 : 인스턴스가 생성될 때마다 인스턴스마다 초기화
- 초기화 순서
  - 클래스 변수 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
  - 인스턴스 변수 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

<!-- Chapter 7 -->
## **상속(Inheritance)**
- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

## **클래스간 관계**
- 상속 관계 : 기존 클래스의 멤버를 그대로 새로운 클래스로 가져오는 관계
- 포함 관계 : 기존 클래스의 인스턴스를 새로운 클래스에 생성하여 사용하는 관계

## **오버라이딩(Overriding)**
- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것

## **패키지(Package)**
- 서로 관련 있는 클래스의 묶음

## **제어자(Modifier)**
- 클래스, 변수 또는 메서드의 선언부에 함께 사용하여 부가적인 의미를 나타내는 것
- 접근 제어자(Access modifier)
  - public : 접근 제한이 없음을 의미
  - protected : 같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 가능함을 의미
  - (default) : 같은 패키지 내에서만 접근 가능함을 의미
  - private : 같은 클래스 내에서 접근 가능함을 의미
- 그 외 제어자
  - static : 인스턴스 생성과 관계 없이 사용 가능 함을 의미
  - final : 마지막 또는 변경될 수 없음을 의미
  - abstract : 미완성임을 의미

## **다형성(Polymorpism)**
- 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 한 것

## **추상 클래스(Abstract class)**
- 미완성(추상) 메서드를 포함하고 있는 클래스

## **추상 메서드(Abstract method)**
- 메서드의 선언부만 작성하고 구현부는 작성하지 않은 메서드

## **인터페이스(Interface)**
- 오직 추상 메서드와 상수만을 멤버로 갖는 일종의 추상 클래스

## **익명 클래스(Anonymous class)**
- 클래스 선언과 인스턴스 생성을 동시에 하는 상속 방법 중 하나로 한번만 사용되고 하나의 객체만 생성해야 하는 상황에 사용되는 일회용 클래스

---

## **지네릭스(Generics)**
- 클래스나 메서드 내에서 다룰 객체의 타입을 미리 명시하는 것
- 객체의 타입을 미리 명시 하기 때문에 의도한 타입의 객체만 사용되도록 할 수 있는 장점이 있다.
- 클래스나 메서드의 선언부 꺽어진 괄호(<>)를 사용하여 에 타입을 미리 명시하여 사용한다.

<!-- ## **와일드 카드(Wild card)**
- 제네릭스에서 변수 타입의 상한과 하한을 정하는 것 -->

## **열거형(Enums)**
- 관련 있는 여러 상수를 한 번에 묶어서 선언하기 위한 것
- 열거형을 사용하면 코드가 짧아지고, 상수를 열거형 타입으로 감싸 유용하게 사용할 수 있다.
- enum 키워드와 중괄호를 사용하여 열겨형을 사용할 수 있다.

## **애너테이션(Annotation)**
- 컴파일러와 같은 프로그램에게 코드의 정보를 제공하는 것
- 코드의 정보를 미리 제공해 의도치 않은 실수를 방지할 수 있다.
- 애너테이션을 사용하고자 하는 대상 앞에 골뱅이 문자(@)와 애너테이션 이름을 적어서 사용한다.

## **프로세스(Process)**
- 메모리에 적재된 현재 실행 중인 프로그램
- 실행 중인 프로그램을 구분하고 자원을 할당하기 위해서 프로세스라는 개념을 사용한다.
- 프로그램을 실행하면 운영체제로 부터 실행에 필요한 자원을 할당받아 프로세스가 된다.

## **쓰레드(Thread)**
- 프로세스 내의 작업 흐름
- 하나의 프로세스 안에서 여러 부분을 실행하기 위해 쓰레드를 사용한다.
- Thread 클래스를 상속하거나, Runnable 인터페이스를 구현해서 사용한다.

## **데몬 쓰레드(Daemon Thread)**
- 일반 쓰레드를 돕는 보조 쓰레드
- 가비지 컬렉터, 자동 저장, 화면 자동 갱신

## **람다식(Lambda expression)**
- 메서드를 값을 나타내는 식으로 표현한 것, 메서드를 변수처럼 다루는 것
- 클래스나 객체 생성 없이 사용 가능하고, 변수처럼도 사용 가능하므로 편리하다.
- 메서드의 이름과 반환문을 없애고, 매개 변수 선언부와 메서드 구현부만 남겨 익명 함수처럼 사용한다.

## **함수형 인터페이스(Functional interface)**
- 람다식이 실제로 선언되어 있는 익명 인터페이스
- 람다식을 사용하면 자동으로 객체가 생성되도록 하여 클래스나 객체 생성 없이 람다식을 사용할 수 있도록 한다.
- 익명 클래스를 생성함과 동시에 람다식으로 사용할 메서드를 선언하면 함수형 인터페이스가 되고 람다식으로 사용할 수 있다.

## **스트림(Stream)**
- 자료 구조의 형태에 관계없이 데이터를 동일하게 다룰 수 있게 자료 구조를 추상화한 것
- 같은 기능의 메서드가 다른 자료 구조에 중복 정의되어 있지만 상이한 방식으로 다룰 때의 문제를 해결하기 위해 스트림을 사용한다.
- 다른 형태의 자료 구조를 스트림 형태로 변환하면 같은 기능을 동일한 방식으로 실행할 수 있다.