---
title: "[Shorts] 자료구조 & 알고리즘"
excerpt: "자료구조와 알고리즘 정리"

categories:
  - Shorts
tags:
  - 

toc: true
toc_sticky: true
 
date: 2022-10-01
last_modified_at: 2022-12-07
---
개인적인 의견이 포함되어 있고, 잘못된 정보가 있을 수 있습니다.

## **자료구조**
- 데이터를 관리하는 방법
- CRUD의 효율성을 높이기 위해 자료구조가 존재한다.

## **추상화(Abstraction)**
- 구체적인 내용을 생략하고 가장 중요한 내용만 드러내어서 틀을 만드는 것
- 구체화 전에 추상화를 통해 틀을 마련할 수 있다. 추상화라는 틀을 이용해서 구체화를 여러번 할 수 있다.

## **추상 데이터 타입(Abstract data type)**
- 추상적인 기능을 포함하는 클래스
- 구체적인 클래스를 작성하기 위한 틀로써 추상 데이터 타입을 사용한다.

## **재귀(Recursion)**
- 내 안에서 나를 찾는 것이다. 경계 조건과 재귀 호출, 관계르 포함하여야 한다.
- 어떤 기능을 반복적으로 수행하기 위해서 사용한다.

## **점근적 복잡도(Asymptotic complexity)**
- 입력의 크기가 충분히 클 때의 복잡도
- 입력의 크기가 작으면 알고리즘 수행 시간의 차이가 거의 없으므로 점근적 복잡도를 이용한다.

## **점근적 표기법**
- 점근적 복잡도를 이용하여 알고리즘의 시간 복잡도를 표기하는 방법
  - O(Big O) 표기 : 최고 차항의 차수를 넘지 않는 모든 함수의 집합
  - Θ(Seta) 표기 : 최고 차항의 차수와 동일한 함수의 집합
  - Ω(Omega) 표기 : 최고 차항의 차수를 넘는 모든 함수의 집합

## **리스트(List)**
- 데이터를 줄 세워 관리하는 방법
- 데이터를 연속적인(물리적 혹은 논리적) 형태로 관리해야할 때 사용하는 자료구조

## **배열 리스트(Array list)**
- 배열을 활용해서 데이터를 줄 세우는 것
- 배열의 공간 연속성을 활용해 데이터 조회(Retrieve)와 변경(Update)이 쉽기 때문에 배열 리스트를 사용한다.

## **연결 리스트(Linked list)**
- 링크를 활용해서 데이터를 줄 세우는 것
- 링크의 연결만 바꿔주면 되므로 데이터 생성(Create)과 삭제(Delete)가 용이하기 때문에 연결 리스트를 사용한다.

## **스택(Stack)**
- 데이터를 줄 세우고, 선입후출 방식으로 관리하는 방법
- 최근에 추가된 데이터가 가장 먼저 사용되어야 할 때 스택을 사용한다.

## **큐(Queue)**
- 데이터를 줄 세우고, 선입후출 방식으로 관리하는 방법
- 최근에 추가된 데이터가 가장 나중에 사용되어야 할 때 큐를 사용한다.

## **힙(Heap)**
- 우선순위에 따라 데이터를 관리하는 방법, 이진 트리로 구현한다.

## **이진 트리(Binary Tree)**
- 자식 노드가 2개 이하인 트리

## **포화 이진 트리(Full Binary Tree)**
- 모든 층의 노드가 가득 찬 이진 트리, 노드의 개수가 (2^n - 1)개인 이진 트리

## **완전 이진 트리(Complete Binary Tree)**
- 마지막 층을 제외한 모든 층의 노드가 가득차고, 마지막 층의 좌측부터 노드가 채워진 이진 트리

## **힙의 조건**
- 완전 이진 트리
- 모든 노드는 값을 갖고, 항상 자식 노드보다 크거나(최대힙) 작아야(최소힙) 한다.

## **이진 검색 트리(Binary Search Tree)**
- 부모 노드는 왼쪽 자식노드 보다 큰 값을 가지고, 오른쪽 자식노드 보다 작은 값을 가지는 이진 트리

## **균형 검색 트리(Blanced Search Tree)**
- 이진 검색 트리의 좌우 균형을 맞춘 트리

## **해쉬 테이블(Hash Table)**
- 데이터의 값이 곧 저장될 위치가 되도록 데이터를 관리하는 방법

## **해쉬 함수(Hash Function)**
- 데이터의 값을 받아 해쉬 테이블 상에 저장될 위치를 반환하는 함수

---

## **알고리즘(Algorithm)**
- 문제를 해결하는 방법, 입력을 받고 자료구조를 활용해서 원하는 출력을 만들어 내는 과정

## **점화식**
- 어떤 함수를 자신과 똑같은 함수를 이용해 나타내는 것, f(n) = n * f(n - 1)

## **선택 정렬(Selection Sort)**
- 가장 큰 원소를 선택해서 배열의 끝자리에 있는 원소와 자리를 바꾸는 정렬

## **버블 정렬(Bubble Sort)**
- 서로 인접한 원소의 대소 비교를 통해 가장 큰 원소를 배열의 끝자리로 보내는 정렬 

## **삽입 정렬(Insertion Sort)**
- 정렬된 최소 크기의 배열에 원소를 삽입해서 정렬된 배열의 길이를 늘려 나가는 정렬

## **병합 정렬(Merge Sort)**
- 배열을 반으로 나눈 뒤, 나눈 두 부분을 각각 정렬한 후 병합하는 정렬, 재귀적으로 호출하여 원소 단위부터 정렬을 수행한다.

## **퀵 정렬(Quick Sort)**
- 기준 원소보다 작은 원소를 기준 원소의 좌측에, 큰 원소를 기준 원소의 우측에 배치하는 정렬, 재귀적으로 호출하여 원소 단위부터 정렬을 수행한다.

## **힙 정렬(Heap Sort)**
- 힙의 조건을 만족하도록 배열을 만드는 정렬

## **동적 프로그래밍(Dynamic Programming)**
- 큰 문제의 해답을 구하기 위해 작은 문제의 해답을 찾는 과정에서 재귀적 중복을 제거하는 방법

## **최적 부분 구조(Optimal Substructure)**
- 큰 문제의 해답에 그보다 작은 문제의 해답이 포함된 구조

## **메모하기(Memoization)**
- 재귀 호출을 사용하되, 한 번 호출된 것을 메모하여 다시 호출하지 않도록 하는 동적 프로그래밍 방법

## **하향식 방법(Top-down)**
- 큰 문제의 정답을 구하기 위해 작은 문제의 정답을 구하는 방식

## **상향식 방법(Bottom-up)**
- 작은 문제의 정답으로부터 큰 문제의 정답을 구하는 방식

## **너비 우선 탐색(Breadth-First Search, BFS)**
- 그래프에서 옆으로(너비로) 모든 노드를 방문하는 방법

## **깊이 우선 탐색(Depth-First Search, DFS)**
- 그래프에서 아래로(깊이로) 모든 노드를 방문하는 방법

## **그리디 알고리즘(Greedy Algorithm)**
- 당장에 가장 좋아 보이는 선택을 반복해서 문제를 해결하는 알고리즘

## **백트래킹(Backtracking)**
- 탐색을 하다가 더 나아갈 수 없으면 왔던 길로 되돌아가 다른 길을 찾는 알고리즘

## **브루트 포스 알고리즘(Brute Force Algorithm)**
- 가능한 모든 경우의 수를 고려하여 문제를 해결하는 알고리즘

## ****

## ****

## ****