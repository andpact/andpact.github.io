---
title: "[Spring] 스프링 애너테이션"
excerpt: "스프링 애네테이션 정리"

categories:
  - Spring
tags:
  - 

toc: 
toc_sticky: 
 
date: 2023-03-07
last_modified_at: 2023-03-07
---
## **스프링 애너테이션**
<br>

# **@Autowired**
- **적용 대상** : 1. 생성자, 2. 메서드, 3. 파라미터, 4. 변수, 5. 애너테이션
- **적용 기간** : 실행 동안

생성자, 필드, Setter 메서드 또는 메서드를 Spring의 의존성 주입 기능에 의해 자동 주입되도록 표시합니다.
<br>
<br>
JSR-330의 @Inject의 대안으로서 의존성 주입을 인자에 의해 선택할 수 있는 개념이 추가된 애너테이션입니다.
{: .notice}

<!-- 1. **@Autowired 생성자**

Bean에 해당하는 클래스의 생성자 중 하나만 이 애너테이션을 적용할 수 있으며, required 속성을 true로 설정하여야한다. 스프링에서 Bean으로 사용될 때 자동으로 주입될 생성자를 나타냅니다.
<br>
<br>
또한 required 속성이 true로 설정된 경우, 하나의 생성자만 해당 애너테이션을 적용할 수 있습니다. required 속성이 false로 설정된 여러개의 생성자는 의존성 주입의 후보로 간주됩니다.
<br>
<br>
Bean을 주입하여, 의존성이 가장 큰 생성자가 스프링 컨테이너에의해 선택됩니다. 어느 생성자도 만족할 수 없는 경우 주된 혹은 기본 생성자(존재하는 경우)가 사용됩니다.
<br>
<br>
마찬가지로 클래스가 여러 생성자를 선언하지만 해당 애네테이션을 주석으로 달지 않으면 주된 혹은 기본 생성자(존재하는 경우)가 사용됩니다.
<br>
<br>
클래스가 처음부터 하나의 생성자만 선언하는 경우 애너테이션이 없는 경우에도 항상 사용됩니다. 주석이 달린 생성자는 공개될 필요가 없습니다.
{: .notice}

2. **@Autowired 메서드**

메서드는 임의의 이름과 여러개의 인수를 가질 수 있습니다. 이러한 인수 각각은 스프링 컨테이너에 의해 일치하는 Bean으로 자동 주입됩니다. Bean 속성 Setter 메서드는 일반 메서드와 다른 경우이고, 해당 메서드는 public으로 사용될 필요가 없기에 본 애너테이션을 사용하지 않습니다.
{: .notice}

3. **@Autowired 변수**

메서드가 호출되기 전에 Bean을 구성한 후 변수가 주입됩니다. 이러한 변수는 public으로 사용될 필요가 없습니다.
{: .notice}

4. **@Autowired 파라미터**

해당 애너테이션은 스프링 5.0 이후 메서드 또는 생성자 파라미터에 선언할 수 있지만 스프링은 대부분 이러한 선언을 무시합니다. @Autowired 파라미터를 적극적으로 지원하는 유일한 부분은 스프링 테스트 모듈의 Junit Jupiter입니다.
{: .notice}

5. **@Autowired 배열, 컬렉션, 맵**

배열, 컬렉션 또는 맵에 해당하는 의존성 유형의 경우 스프링 컨테이너는 선언된 해당 유형과 일치하는 모든 Bean을 자동으로 주입합니다. 이러한 목적을 위해 맵의 키는 Bean이름으로 인식되는 문자열 유형으로 선언되어야 합니다. 이러한 컬렉션은

배열, 컬렉션 또는 맵 종속성 유형의 경우 컨테이너는 선언된 값 유형과 일치하는 모든 빈을 자동으로 배선합니다. 이러한 목적을 위해 맵 키는 해당 빈 이름으로 확인되는 String 유형으로 선언되어야 합니다.
{: .notice} -->

# **@Bean**
- **적용 대상** : 1. 메서드, 2. 애너테이션
- **적용 기간** : 실행 동안

메서드가 스프링 컨테이너에서 관리할 빈을 생성함을 나타냅니다.
{: .notice}

# **@Component**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

해당 애너테이션이 달린 클래스가 "구성 요소"임을 나타냅니다. 이러한 클래스들은 애너테이션 기반 구성 및 클래스 탐색을 사용할 때 자동으로 탐지될 후보로 간주됩니다.
<br>
<br>
@Repository 또는 AspectJ의 @Aspect 애너테이션과 같은 클래스 레벨 애너테이션 또한 구성 요소로 식별되는 것으로 간주 될 수 있습니다.
{: .notice}

# **@ComponentScan**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

@Configuration 클래스와 함께 사용되어, 컴포넌트 탐색 방법을 구성합니다. 스프링 XML의 \<context:component-scan> 요소와의 병렬 지원을 제공합니다.
{: .notice}

# **@Configuration**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

해당 클래스가 하나 이상의 @Bean 메소드를 선언하고 있고, 해당 Bean의 정의 또는 서비스 요청을 만들기 위해 프로그램이 실행되는 동안 스프링 컨테이너에 의해 처리됨을 나타냅니다.
{: .notice}

# **@Controller**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

해당 클래스가 "컨트롤러"임을 나타냅니다.
<br>
<br>
이 애너테이션은 @Component의 특수화로 사용되어 클래스 경로 탐색을 통해 해당 클래스를 자동 탐지할 수 있습니다.
<br>
<br>
일반적으로 @RequestMapping 기반의 요청 핸들러 메서드와 함께 사용됩니다.
{: .notice}

# **@GetMapping**
- **적용 대상** : 1. 메서드
- **적용 기간** : 실행 동안

HTTP GET 요청을 특정 핸들러 메서드에 매핑하기 위한 애너테이션 입니다.
<br>
<br>
@RequestMapping(method = RequestMethod.GET)과 동일한 역할을 하는 애너테이션입니다.
{: .notice}

# **@PostMapping**
- **적용 대상** : 1. 메서드
- **적용 기간** : 실행 동안

HTTP POST 요청을 특정 핸들러 메서드에 매핑하기 위한 주석입니다.
<br>
<br>
@RequestMapping(method = RequestMethod.POST)과 동일한 역할을 하는 애너테이션입니다.
{: .notice}

# **@PutMapping**
- **적용 대상** : 1. 메서드
- **적용 기간** : 실행 동안

HTTP PUT 요청을 특정 핸들러 메서드에 매핑하기 위한 주석입니다.
<br>
<br>
@RequestMapping(method = RequestMethod.PUT)과 동일한 역할을 하는 애너테이션입니다.
{: .notice}

# **@Repository**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

해당 클래스가 "리포지터리"임을 나타냅니다.
<br>
<br>
스프링 2.5부터 이 애너테이션은 @Component의 특수화 역할을 수행하여 클래스 경로 탐색을 통해 해당 클래스를 자동으로 감지할 수 있도록 합니다
{: .notice}

# **@RequestBody**
- **적용 대상** : 1. 파라미터
- **적용 기간** : 실행 동안

메서드의 파라미터를 나타내는 이 애너테이션은 웹 요청의 Body와 연결되어야 합니다.
<br>
<br>
애너테이션처리된 핸들러 메서드에 의해 사용됩니다.
{: .notice}

# **@RequestMapping**
- **적용 대상** : 1. 클래스, 2. 메서드
- **적용 기간** : 실행 동안

요청을 처리하는 클래스 내에서 웹 요청을 메서드에 매핑하기 위한 애너테이션입니다.
{: .notice}

# **@RestController**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

@Controller 및 @ResponseBody의 역할을 수행하는 애너테이션입니다.
<br>
<br>
이 애너테이션 포함하는 클래스은 @RequestMapping 메서드가 기본적으로 @ResponseBody 개념을 가정하는 컨트롤러로 처리됩니다.
{: .notice}

# **@Service**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

해당 클래스가 "서비스 객체"임을 나타냅니다
<br>
<br>
이 애너테이션은 @Component의 특수화 역할을 하며, 클래스 경로 탐색을 통해 해당 클래스를 자동으로 탐지할 수 있습니다.
{: .notice}
<br>
<br>

## **스프링 부트 애너테이션**
<br>

# **@SpringBootApplication**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

하나 이상의 @Bean 메서드를 선언하고, 자동 구성과 컴포넌트 탐색을 일으키는 구성 클래스를 나타낸다.
<br>
<br>
@Configuration, @EnableAutoConfiguration 및 @ComponentScan을 적용하는 것과 동일한 애너테이션입니다.
{: .notice}

# **@SpringBootTest**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

스프링 부트 기반 테스트를 실행하는 테스트 클래스에서 적용할 수 있는 애너테이션입니다.
{: .notice}
<br>
<br>

## **스프링 시큐리티 애너테이션**
<br>

# **@EnableMethodSecurity**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

스프링 Security의 Method Security를 활성화합니다.
{: .notice}

# **@EnableWebSecurity**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

이 애너테이션을 @Configuration 클래스에 적용하면 SecurityFilterChain 빈을 노출하여 모든 WebSecurityConfigurer에 SpringSecurity 구성을 정의할 수 있습니다:
{: .notice}

# **@PreAuthorize**
- **적용 대상** : 1. 메서드, 2. 클래스
- **적용 기간** : 실행 동안

메서드 호출이 허용되는지 여부를 결정하기 위해 평가되는 메서드 접근 제어 식을 지정하기 위한 애너테이션입니다.
{: .notice}
<br>
<br>

## **스프링 Data JPA 애너테이션**
<br>

# **@EnableJpaAuditing**
- **적용 대상** : 1. 클래스
- **적용 기간** : 실행 동안

JPA 작업 감사를 활성화하기 위한 애너테이션입니다.
{: .notice}

# **@Query**
- **적용 대상** : 1. 메서드, 2. 애너테이션
- **적용 기간** : 실행 동안

리포지토리 메서드에서 직접 파인더 쿼리를 선언하는 애너테이션입니다.
{: .notice}